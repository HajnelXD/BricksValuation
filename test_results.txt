============================= test session starts ==============================
platform linux -- Python 3.14.0, pytest-8.4.2, pluggy-1.6.0
django: version: 5.2.7, settings: config.settings (from ini)
rootdir: /app
configfile: setup.cfg
plugins: cov-7.0.0, django-4.11.1
collected 277 items

account/serializers/tests/test_registration_serializer.py ....           [  1%]
account/serializers/tests/test_user_profile_serializer.py ............   [  5%]
account/services/tests/test_login_service.py .........                   [  9%]
account/services/tests/test_logout_service.py ...                        [ 10%]
account/services/tests/test_registration_service.py ......               [ 12%]
account/services/tests/test_user_profile_service.py ...........          [ 16%]
account/tests/test_authentication.py ..........                          [ 19%]
account/views/tests/test_login_throttle.py ...                           [ 20%]
account/views/tests/test_login_view.py ...............                   [ 26%]
account/views/tests/test_logout_view.py ......                           [ 28%]
account/views/tests/test_register_view.py ...                            [ 29%]
account/views/tests/test_user_profile_view.py ..............             [ 34%]
catalog/serializers/tests/test_brickset_create_serializer.py ........... [ 38%]
.......                                                                  [ 41%]
catalog/serializers/tests/test_brickset_list_serializer.py ............. [ 45%]
.......................                                                  [ 54%]
catalog/services/tests/test_brickset_create_service.py ........F..F....F [ 60%]
                                                                         [ 60%]
catalog/services/tests/test_brickset_list_service.py ................... [ 67%]
..........                                                               [ 70%]
catalog/views/tests/test_brickset_create_view.py .F.....F...........     [ 77%]
catalog/views/tests/test_brickset_list_view.py ......................... [ 86%]
............                                                             [ 90%]
account/serializers/tests/test_login_serializer.py ...............       [ 96%]
account/services/tests/test_token_provider.py ..........                 [100%]

=================================== FAILURES ===================================
_ CreateBrickSetServiceTests.test_execute_duplicate_error_includes_constraint_name _

    def _validate_brickset(self, brickset: BrickSet) -> None:
        """Validate BrickSet against model constraints."""
        try:
>           brickset.full_clean()

catalog/services/brickset_create_service.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <BrickSet: Set #12345 (Complete)>, exclude = set()
validate_unique = True, validate_constraints = True

    def full_clean(self, exclude=None, validate_unique=True, validate_constraints=True):
        """
        Call clean_fields(), clean(), validate_unique(), and
        validate_constraints() on the model. Raise a ValidationError for any
        errors that occur.
        """
        errors = {}
        if exclude is None:
            exclude = set()
        else:
            exclude = set(exclude)
    
        try:
            self.clean_fields(exclude=exclude)
        except ValidationError as e:
            errors = e.update_error_dict(errors)
    
        # Form.clean() is run even if other validation fails, so do the
        # same with Model.clean() for consistency.
        try:
            self.clean()
        except ValidationError as e:
            errors = e.update_error_dict(errors)
    
        # Run unique checks, but only for fields that passed validation.
        if validate_unique:
            for name in errors:
                if name != NON_FIELD_ERRORS and name not in exclude:
                    exclude.add(name)
            try:
                self.validate_unique(exclude=exclude)
            except ValidationError as e:
                errors = e.update_error_dict(errors)
    
        # Run constraints checks, but only for fields that passed validation.
        if validate_constraints:
            for name in errors:
                if name != NON_FIELD_ERRORS and name not in exclude:
                    exclude.add(name)
            try:
                self.validate_constraints(exclude=exclude)
            except ValidationError as e:
                errors = e.update_error_dict(errors)
    
        if errors:
>           raise ValidationError(errors)
E           django.core.exceptions.ValidationError: {'__all__': ['Brick Set with this Number, Production status, Completeness, Has instructions, Has box and Is factory sealed already exists.']}

/usr/local/lib/python3.14/site-packages/django/db/models/base.py:1679: ValidationError

The above exception was the direct cause of the following exception:

self = <test_brickset_create_service.CreateBrickSetServiceTests testMethod=test_execute_duplicate_error_includes_constraint_name>

    def test_execute_duplicate_error_includes_constraint_name(self) -> None:
        """execute() DuplicateError includes constraint name."""
        command1 = CreateBrickSetCommand(
            number=12345,
            production_status=ProductionStatus.ACTIVE,
            completeness=Completeness.COMPLETE,
            has_instructions=True,
            has_box=True,
            is_factory_sealed=False,
        )
        self.service.execute(command1, self.user)
    
        command2 = CreateBrickSetCommand(
            number=12345,
            production_status=ProductionStatus.ACTIVE,
            completeness=Completeness.COMPLETE,
            has_instructions=True,
            has_box=True,
            is_factory_sealed=False,
        )
    
        with self.assertRaises(BrickSetDuplicateError) as duplicate_error:
>           self.service.execute(command2, self.user)

catalog/services/tests/test_brickset_create_service.py:383: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
catalog/services/brickset_create_service.py:29: in execute
    self._validate_brickset(brickset)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _validate_brickset(self, brickset: BrickSet) -> None:
        """Validate BrickSet against model constraints."""
        try:
            brickset.full_clean()
        except DjangoValidationError as exc:
            errors = self._format_validation_errors(exc)
>           raise BrickSetValidationError(errors) from exc
E           catalog.exceptions.BrickSetValidationError: Invalid BrickSet data.

catalog/services/brickset_create_service.py:53: BrickSetValidationError
_ CreateBrickSetServiceTests.test_execute_raises_duplicate_error_for_identical_combination _

    def _validate_brickset(self, brickset: BrickSet) -> None:
        """Validate BrickSet against model constraints."""
        try:
>           brickset.full_clean()

catalog/services/brickset_create_service.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <BrickSet: Set #12345 (Complete)>, exclude = set()
validate_unique = True, validate_constraints = True

    def full_clean(self, exclude=None, validate_unique=True, validate_constraints=True):
        """
        Call clean_fields(), clean(), validate_unique(), and
        validate_constraints() on the model. Raise a ValidationError for any
        errors that occur.
        """
        errors = {}
        if exclude is None:
            exclude = set()
        else:
            exclude = set(exclude)
    
        try:
            self.clean_fields(exclude=exclude)
        except ValidationError as e:
            errors = e.update_error_dict(errors)
    
        # Form.clean() is run even if other validation fails, so do the
        # same with Model.clean() for consistency.
        try:
            self.clean()
        except ValidationError as e:
            errors = e.update_error_dict(errors)
    
        # Run unique checks, but only for fields that passed validation.
        if validate_unique:
            for name in errors:
                if name != NON_FIELD_ERRORS and name not in exclude:
                    exclude.add(name)
            try:
                self.validate_unique(exclude=exclude)
            except ValidationError as e:
                errors = e.update_error_dict(errors)
    
        # Run constraints checks, but only for fields that passed validation.
        if validate_constraints:
            for name in errors:
                if name != NON_FIELD_ERRORS and name not in exclude:
                    exclude.add(name)
            try:
                self.validate_constraints(exclude=exclude)
            except ValidationError as e:
                errors = e.update_error_dict(errors)
    
        if errors:
>           raise ValidationError(errors)
E           django.core.exceptions.ValidationError: {'__all__': ['Brick Set with this Number, Production status, Completeness, Has instructions, Has box and Is factory sealed already exists.']}

/usr/local/lib/python3.14/site-packages/django/db/models/base.py:1679: ValidationError

The above exception was the direct cause of the following exception:

self = <test_brickset_create_service.CreateBrickSetServiceTests testMethod=test_execute_raises_duplicate_error_for_identical_combination>

    def test_execute_raises_duplicate_error_for_identical_combination(self) -> None:
        """execute() raises BrickSetDuplicateError for duplicate constraint."""
        # Create first BrickSet
        command1 = CreateBrickSetCommand(
            number=12345,
            production_status=ProductionStatus.ACTIVE,
            completeness=Completeness.COMPLETE,
            has_instructions=True,
            has_box=True,
            is_factory_sealed=False,
        )
        self.service.execute(command1, self.user)
    
        # Try to create identical second BrickSet
        command2 = CreateBrickSetCommand(
            number=12345,
            production_status=ProductionStatus.ACTIVE,
            completeness=Completeness.COMPLETE,
            has_instructions=True,
            has_box=True,
            is_factory_sealed=False,
        )
    
        with self.assertRaises(BrickSetDuplicateError) as context:
>           self.service.execute(command2, self.user)

catalog/services/tests/test_brickset_create_service.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
catalog/services/brickset_create_service.py:29: in execute
    self._validate_brickset(brickset)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _validate_brickset(self, brickset: BrickSet) -> None:
        """Validate BrickSet against model constraints."""
        try:
            brickset.full_clean()
        except DjangoValidationError as exc:
            errors = self._format_validation_errors(exc)
>           raise BrickSetValidationError(errors) from exc
E           catalog.exceptions.BrickSetValidationError: Invalid BrickSet data.

catalog/services/brickset_create_service.py:53: BrickSetValidationError
_ CreateBrickSetServiceTests.test_execute_transaction_rollback_on_integrity_error _

    def _validate_brickset(self, brickset: BrickSet) -> None:
        """Validate BrickSet against model constraints."""
        try:
>           brickset.full_clean()

catalog/services/brickset_create_service.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <BrickSet: Set #12345 (Complete)>, exclude = set()
validate_unique = True, validate_constraints = True

    def full_clean(self, exclude=None, validate_unique=True, validate_constraints=True):
        """
        Call clean_fields(), clean(), validate_unique(), and
        validate_constraints() on the model. Raise a ValidationError for any
        errors that occur.
        """
        errors = {}
        if exclude is None:
            exclude = set()
        else:
            exclude = set(exclude)
    
        try:
            self.clean_fields(exclude=exclude)
        except ValidationError as e:
            errors = e.update_error_dict(errors)
    
        # Form.clean() is run even if other validation fails, so do the
        # same with Model.clean() for consistency.
        try:
            self.clean()
        except ValidationError as e:
            errors = e.update_error_dict(errors)
    
        # Run unique checks, but only for fields that passed validation.
        if validate_unique:
            for name in errors:
                if name != NON_FIELD_ERRORS and name not in exclude:
                    exclude.add(name)
            try:
                self.validate_unique(exclude=exclude)
            except ValidationError as e:
                errors = e.update_error_dict(errors)
    
        # Run constraints checks, but only for fields that passed validation.
        if validate_constraints:
            for name in errors:
                if name != NON_FIELD_ERRORS and name not in exclude:
                    exclude.add(name)
            try:
                self.validate_constraints(exclude=exclude)
            except ValidationError as e:
                errors = e.update_error_dict(errors)
    
        if errors:
>           raise ValidationError(errors)
E           django.core.exceptions.ValidationError: {'__all__': ['Brick Set with this Number, Production status, Completeness, Has instructions, Has box and Is factory sealed already exists.']}

/usr/local/lib/python3.14/site-packages/django/db/models/base.py:1679: ValidationError

The above exception was the direct cause of the following exception:

self = <test_brickset_create_service.CreateBrickSetServiceTests testMethod=test_execute_transaction_rollback_on_integrity_error>

    def test_execute_transaction_rollback_on_integrity_error(self) -> None:
        """execute() rolls back transaction on IntegrityError."""
        initial_count = BrickSet.objects.count()
    
        command1 = CreateBrickSetCommand(
            number=12345,
            production_status=ProductionStatus.ACTIVE,
            completeness=Completeness.COMPLETE,
            has_instructions=True,
            has_box=True,
            is_factory_sealed=False,
        )
        self.service.execute(command1, self.user)
    
        command2 = CreateBrickSetCommand(
            number=12345,
            production_status=ProductionStatus.ACTIVE,
            completeness=Completeness.COMPLETE,
            has_instructions=True,
            has_box=True,
            is_factory_sealed=False,
        )
    
        with self.assertRaises(BrickSetDuplicateError):
>           self.service.execute(command2, self.user)

catalog/services/tests/test_brickset_create_service.py:336: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
catalog/services/brickset_create_service.py:29: in execute
    self._validate_brickset(brickset)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _validate_brickset(self, brickset: BrickSet) -> None:
        """Validate BrickSet against model constraints."""
        try:
            brickset.full_clean()
        except DjangoValidationError as exc:
            errors = self._format_validation_errors(exc)
>           raise BrickSetValidationError(errors) from exc
E           catalog.exceptions.BrickSetValidationError: Invalid BrickSet data.

catalog/services/brickset_create_service.py:53: BrickSetValidationError
_____ TestCreateBrickSetView.test_post_duplicate_brickset_returns_conflict _____

self = <catalog.views.tests.test_brickset_create_view.TestCreateBrickSetView testMethod=test_post_duplicate_brickset_returns_conflict>

    def test_post_duplicate_brickset_returns_conflict(self) -> None:
        """POST duplicate BrickSet returns 409 Conflict."""
        self.client.force_authenticate(user=self.user)
        payload = {
            "number": 12345,
            "production_status": "ACTIVE",
            "completeness": "COMPLETE",
            "has_instructions": True,
            "has_box": True,
            "is_factory_sealed": False,
        }
    
        # Create first
        response1 = self.client.post(self.url, payload, format="json")
        assert response1.status_code == status.HTTP_201_CREATED
    
        # Try to create duplicate
        response2 = self.client.post(self.url, payload, format="json")
>       assert response2.status_code == status.HTTP_409_CONFLICT
E       assert 400 == 409
E        +  where 400 = <Response status_code=400, "application/json">.status_code
E        +  and   409 = status.HTTP_409_CONFLICT

catalog/views/tests/test_brickset_create_view.py:272: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  django.request:log.py:253 Bad Request: /api/v1/bricksets
______ TestCreateBrickSetView.test_post_response_includes_all_dto_fields _______

self = <catalog.views.tests.test_brickset_create_view.TestCreateBrickSetView testMethod=test_post_response_includes_all_dto_fields>

    def test_post_response_includes_all_dto_fields(self) -> None:
        """POST response includes all BrickSetListItemDTO fields."""
        self.client.force_authenticate(user=self.user)
        payload = {
            "number": 22222,
            "production_status": "ACTIVE",
            "completeness": "COMPLETE",
            "has_instructions": True,
            "has_box": True,
            "is_factory_sealed": False,
            "owner_initial_estimate": 500,
        }
    
        response = self.client.post(self.url, payload, format="json")
    
        assert response.status_code == status.HTTP_201_CREATED
        data = response.data
        assert "id" in data
        assert "number" in data
        assert "production_status" in data
        assert "completeness" in data
        assert "has_instructions" in data
        assert "has_box" in data
        assert "is_factory_sealed" in data
        assert "owner_id" in data
        assert "owner_initial_estimate" in data
        assert "valuations_count" in data
        assert "total_likes" in data
        assert "top_valuation" in data
>       assert "created_at" in data
E       AssertionError: assert 'created_at' in {'id': 113, 'number': 22222, 'production_status': 'ACTIVE', 'completeness': 'COMPLETE', 'has_instructions': True, 'has... False, 'owner_id': 174, 'owner_initial_estimate': 500, 'valuations_count': 0, 'total_likes': 0, 'top_valuation': None}

catalog/views/tests/test_brickset_create_view.py:147: AssertionError
=============================== warnings summary ===============================
account/models/user.py:97
  /app/account/models/user.py:97: RemovedInDjango60Warning: CheckConstraint.check is deprecated in favor of `.condition`.
    models.CheckConstraint(

account/models/user.py:101
  /app/account/models/user.py:101: RemovedInDjango60Warning: CheckConstraint.check is deprecated in favor of `.condition`.
    models.CheckConstraint(

catalog/models/brickset.py:107
  /app/catalog/models/brickset.py:107: RemovedInDjango60Warning: CheckConstraint.check is deprecated in favor of `.condition`.
    models.CheckConstraint(

catalog/models/brickset.py:111
  /app/catalog/models/brickset.py:111: RemovedInDjango60Warning: CheckConstraint.check is deprecated in favor of `.condition`.
    models.CheckConstraint(

valuation/models/valuation.py:61
  /app/valuation/models/valuation.py:61: RemovedInDjango60Warning: CheckConstraint.check is deprecated in favor of `.condition`.
    models.CheckConstraint(

valuation/models/valuation.py:65
  /app/valuation/models/valuation.py:65: RemovedInDjango60Warning: CheckConstraint.check is deprecated in favor of `.condition`.
    models.CheckConstraint(

../usr/local/lib/python3.14/site-packages/_pytest/config/__init__.py:1533
  /usr/local/lib/python3.14/site-packages/_pytest/config/__init__.py:1533: PytestConfigWarning: No files were found in testpaths; consider removing or adjusting your testpaths configuration. Searching recursively from the current directory instead.
    self.args, self.args_source = self._decide_args(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
================================ tests coverage ================================
_______________ coverage: platform linux, python 3.14.0-final-0 ________________

Name                                          Stmts   Miss  Cover   Missing
---------------------------------------------------------------------------
account/apps.py                                   4      0   100%
account/authentication.py                        37      0   100%
account/exceptions.py                            19      2    89%   28-29
account/models/user.py                           21      0   100%
account/serializers/login.py                     17      0   100%
account/serializers/registration.py              14      0   100%
account/serializers/user_profile.py               8      0   100%
account/services/login_service.py                21      0   100%
account/services/logout_service.py                6      0   100%
account/services/registration_service.py         49      0   100%
account/services/token_provider.py               25      0   100%
account/services/user_profile_service.py         13      0   100%
account/throttling.py                            10     10     0%   2-33
account/views/login.py                           27      0   100%
account/views/logout.py                          17      0   100%
account/views/register.py                        24      0   100%
account/views/user_profile.py                    21      0   100%
catalog/apps.py                                   4      0   100%
catalog/exceptions.py                            11      3    73%   19-21
catalog/models/brickset.py                       41      4    90%   39, 43, 47, 51
catalog/serializers/brickset_create.py           19      0   100%
catalog/serializers/brickset_list.py             39      0   100%
catalog/services/brickset_create_service.py      39      3    92%   60-61, 72
catalog/services/brickset_list_service.py        56      0   100%
catalog/views/brickset_create.py                 26     12    54%   41-67
catalog/views/brickset_list.py                   47      4    91%   76-77, 113-114
config/jwt_config.py                             10      0   100%
datastore/domains/account_dto.py                 32      0   100%
datastore/domains/catalog_dto.py                 78      0   100%
valuation/apps.py                                 4      0   100%
valuation/models/like.py                         14      0   100%
valuation/models/metrics.py                      12      0   100%
valuation/models/valuation.py                    26      2    92%   19, 22
valuation/signals.py                             26     17    35%   22-57, 62-67, 72-78
---------------------------------------------------------------------------
TOTAL                                           817     57    93%
Coverage HTML written to dir htmlcov
Required test coverage of 90% reached. Total coverage: 93.02%
=========================== short test summary info ============================
FAILED catalog/services/tests/test_brickset_create_service.py::CreateBrickSetServiceTests::test_execute_duplicate_error_includes_constraint_name
FAILED catalog/services/tests/test_brickset_create_service.py::CreateBrickSetServiceTests::test_execute_raises_duplicate_error_for_identical_combination
FAILED catalog/services/tests/test_brickset_create_service.py::CreateBrickSetServiceTests::test_execute_transaction_rollback_on_integrity_error
FAILED catalog/views/tests/test_brickset_create_view.py::TestCreateBrickSetView::test_post_duplicate_brickset_returns_conflict
FAILED catalog/views/tests/test_brickset_create_view.py::TestCreateBrickSetView::test_post_response_includes_all_dto_fields
================== 5 failed, 272 passed, 7 warnings in 22.78s ==================
